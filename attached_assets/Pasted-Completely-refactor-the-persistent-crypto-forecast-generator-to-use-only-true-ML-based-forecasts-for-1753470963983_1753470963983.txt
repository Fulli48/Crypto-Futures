Completely refactor the persistent crypto forecast generator to use only true ML-based forecasts for the next 20 minutes (one forecast per minute), using the last 60 minutes of real, feature-enriched chart data and the latest learned feature weights. Remove all simulation/random-walk code. Do the following each time a forecast is needed or refreshed: 1) Query the database for the most recent 60 rows (oldest to newest) of per-minute chart data for the target symbol: 
const inputWindow = await db.select().from(chartTable).where(eq(chartTable.symbol, symbol)).orderBy(chartTable.timestamp).limit(60); 
2) For each row, extract an array of features needed by your ML model, e.g. [row.rsi, row.macd, row.bollingerMid, row.bollingerUpper, row.bollingerLower, row.stochK, row.stochD, row.ema9, row.ema21, row.ema50, row.ema200, row.supportLevel, row.resistanceLevel, row.marketStructure, row.patternType, row.volatility, row.volumeProfile, row.volume]: 
const features = inputWindow.map(row => [row.rsi, row.macd, row.bollingerMid, row.bollingerUpper, row.bollingerLower, row.stochK, row.stochD, row.ema9, row.ema21, row.ema50, row.ema200, row.supportLevel, row.resistanceLevel, row.marketStructure, row.patternType, row.volatility, row.volumeProfile, row.volume]); 
3) Fetch the current learned weights for this symbol from your ML learning system: 
const learnedWeights = await getCurrentLearnedWeights(symbol); 
4) Call your ML model’s sequence forecast function with the extracted features and weights to predict the next 20 minutes: 
const forecastSequence = await mlModel.predictSequence(features, 20, learnedWeights); // Returns [{open, high, low, close, volume, confidence, volatility, trendDirection, supportLevel, resistanceLevel}, ...] 
5) Create and persist a new forecast: 
const timestamp = new Date(); 
const forecastKey = symbol + '_' + timestamp.getTime(); 
const [persistentForecast] = await db.insert(persistentForecasts).values({ symbol, forecastKey, baseTimestamp: timestamp, basePrice: inputWindow[59].close.toString(), isActive: true, forecastType: 'ML_SEQUENCE', confidenceScore: forecastSequence[0].confidence }).returning(); 
const forecastPointsData = forecastSequence.map((point, i) => ({ forecastId: persistentForecast.id, futureTimestamp: new Date(timestamp.getTime() + (i + 1) * 60000), minutesAhead: i + 1, predictedOpen: point.open, predictedHigh: point.high, predictedLow: point.low, predictedClose: point.close, predictedVolume: point.volume, confidence: point.confidence, volatility: point.volatility, trendDirection: point.trendDirection, supportLevel: point.supportLevel, resistanceLevel: point.resistanceLevel })); 
await db.insert(persistentForecastPoints).values(forecastPointsData); 
6) Mark any previous active forecasts for this symbol as inactive if needed. 7) On every subsequent live update, repeat this entire process—always use only the latest 60 minutes of chart data, extract fresh features, call the ML model, and persist the resulting 20-step sequence as the only valid forecast. All downstream trade suggestions and UI visualizations must display only these ML-driven, per-minute forecasts. No random or synthetic generation is to be used anywhere.